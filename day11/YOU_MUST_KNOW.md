# YOU_MUST_KNOW: Day 11

## 1. 계정별 nonce
- 이더리움에서 한 계정(sender)은 트랜잭션마다 nonce를 0, 1, 2처럼 순서대로 증가시켜야 합니다.
- nonce가 비어 있는 상태에서 5번 트랜잭션을 먼저 실행하면 계정 상태가 꼬이므로, 풀에서는 항상 가장 낮은 nonce부터 내보내야 합니다.
- 이를 위해 계정별로 FIFO 큐(먼저 들어온 것이 먼저 나가는 구조)를 사용하는 것이 자연스럽습니다.

## 2. 우선순위 큐(Max-Heap)
- 우선순위 큐는 항상 "가장 점수가 높은" 데이터를 바로 꺼낼 수 있는 자료구조입니다.
- Rust의 `BinaryHeap`은 기본적으로 최대 힙이어서, `Ord` 구현이 클수록 먼저 나옵니다.
- `(priority, gas_price)`처럼 두 개의 값을 튜플로 비교하면 첫 번째 값이 크면 우선, 같으면 두 번째 값을 비교해 순서를 정할 수 있습니다.

## 3. Lazy Eviction
- BinaryHeap은 중간에 있는 항목을 바로 제거할 수 없습니다. 대신 "나중에 꺼낼 때" 제거하는 전략을 사용합니다.
- 이미 제거된 트랜잭션이 global_queue에 남아 있다면 pop하면서 실제 상태(per_account)와 비교해 건너뜁니다.
- 이렇게 하면 성능을 희생하지 않고도 일관성을 유지할 수 있습니다.

## 4. Capacity와 Account Slots
- 풀 전체 용량(capacity)은 메모리 한도를 뜻합니다. 너무 많은 트랜잭션이 쌓이면 네트워크가 멈출 수 있으므로 제한이 필요합니다.
- 계정별 슬롯(max_account_slots)은 한 계정이 풀을 독식하지 못하게 막아주는 장치입니다.
- 두 제한을 함께 적용하면 봇이나 공격자가 한 계정으로 트랜잭션을 쏟아낼 때도 전체 풀을 보호할 수 있습니다.

## 5. 배치 추출(pop_batch)
- 실행 엔진은 한 번에 여러 트랜잭션을 처리하길 원합니다. 그래서 풀은 일정 개수만큼 묶어서 제공합니다.
- pop할 때마다 동일 sender의 다음 nonce를 global_queue에 다시 넣어주어야 전체 순서가 유지됩니다.
- 배치 결과를 priority 순서로 정렬하면 다운스트림 컴포넌트가 단순하게 소비할 수 있습니다.
