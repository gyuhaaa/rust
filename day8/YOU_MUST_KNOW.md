# YOU_MUST_KNOW Day 8

## 계정 잠금(Account Locking)이란?
- 블록체인에서 트랜잭션은 여러 계정(또는 상태 조각)에 동시에 접근합니다.
- 두 트랜잭션이 같은 계정을 동시에 수정하면, 결과가 예측 불가능해져 전체 상태가 망가질 수 있습니다.
- 그래서 "잠금"이라는 개념을 사용해, 한 번에 한 트랜잭션만 특정 계정에 쓰기 권한을 갖도록 막습니다.
- 읽기 전용 계정은 여러 트랜잭션이 동시에 읽을 수 있지만, 누군가가 그 계정을 쓰려고 한다면 먼저 읽기 잠금을 해제해야 합니다.

## 왜 HashSet을 사용할까?
- `HashSet`은 특정 값이 포함되어 있는지 `contains`로 빠르게 확인할 수 있는 자료구조입니다.
- 평균적으로 O(1)에 가까운 시간으로 조회가 가능하므로, 잠금 여부를 자주 확인해야 하는 상황에 적합합니다.
- 트랜잭션 수가 많아져도 탐색 시간이 크게 늘어나지 않아 효율적입니다.

## 읽기와 쓰기를 구분해야 하는 이유
- 읽기 전용 계정은 데이터를 조회만 하므로 동시에 접근해도 안전합니다.
- 반대로 쓰기 가능한 계정은 데이터를 변경하므로, 두 개 이상의 트랜잭션이 동시에 쓰려고 하면 충돌이 발생합니다.
- 따라서 "읽기 vs 쓰기" 목록을 따로 관리해, 쓰기 요청이 들어왔을 때 이미 읽거나 쓰고 있는 트랜잭션이 없는지 확인해야 합니다.

## 컴퓨트 유닛 제한이 중요한 이유
- Solana 같은 블록체인은 트랜잭션이 사용할 수 있는 컴퓨트 자원을 제한합니다.
- 제한이 없다면, 한 트랜잭션이 지나치게 많은 연산을 수행해 블록 시간 안에 끝나지 않을 수 있습니다.
- 각 트랜잭션이 얼마만큼의 컴퓨트 유닛을 사용할지 기록하고, 제한을 넘지 않게 조절하는 것이 필요합니다.

## Result와 에러 타입을 쓰는 이유
- `Result<T, E>`는 성공(`Ok`)과 실패(`Err`)를 명확하게 표현할 수 있는 Rust의 표준 타입입니다.
- 이번 과제에서는 실패 이유를 `AccountLockError`로 표현해, 어떤 문제(충돌인지, 컴퓨트 초과인지)를 정확히 알려줍니다.
- 이렇게 하면 호출하는 쪽에서 실패 원인을 구분해 다른 행동(대기, 재시도, 포기 등)을 결정할 수 있습니다.

## `VecDeque`가 유용한 상황
- 대기열(Queue)은 앞에서 꺼내고 뒤에 넣는 패턴이 반복됩니다.
- `VecDeque`는 앞과 뒤 양쪽에서 요소를 추가/제거할 때 효율적인 자료구조입니다.
- 일반 `Vec`은 앞에서 요소를 제거하면 나머지 요소를 모두 옮겨야 하기 때문에 덜 효율적입니다.

## 전체 흐름 요약
1. 새로운 트랜잭션이 들어오면, 먼저 컴퓨트 유닛 제한을 초과하는지 확인합니다.
2. 다음으로 읽기/쓰기 계정이 이미 잠겨 있는지 검사합니다.
3. 문제가 없다면 상태(`SlotExecutionState`)를 업데이트하고 대기열에 추가합니다.
4. 트랜잭션 처리가 끝나면 `release`를 호출해 계정 잠금을 해제하고, 다른 트랜잭션이 같은 계정을 사용할 수 있게 합니다.

이 과정을 반복하면 동시에 안전하게 실행할 수 있는 트랜잭션 묶음을 만들 수 있습니다. 이 개념은 실제 Solana 실행 엔진에서도 핵심 역할을 합니다.
