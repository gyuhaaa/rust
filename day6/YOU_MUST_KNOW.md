# Day 6 YOU_MUST_KNOW

## BinaryHeap이 뭐예요?
- `BinaryHeap`은 가장 큰(또는 작은) 값을 바로 꺼낼 수 있게 정리해 두는 상자입니다.
- 마치 놀이공원 줄에서 VIP가 먼저 타는 것처럼, 점수가 높은 것이 먼저 나옵니다.
- 내부에서는 이진 트리 모양을 사용하지만, 우리는 `push`, `pop`만 호출하면 됩니다.

## 우선순위 점수는 어떻게 계산하나요?
- 수수료가 높은 트랜잭션은 블록에 더 빨리 포함되길 원합니다.
- 오늘은 `score = fee * 1000 + (200_000 - compute_units)` 공식을 사용합니다.
  - 수수료를 크게 곱해서 제일 중요한 지표로 만들고,
  - 사용한 계산 자원(`compute_units`)이 적을수록 조금 더 점수를 줍니다.
- 이렇게 하면 두 트랜잭션이 수수료가 같을 때, 더 가벼운 트랜잭션이 앞에 옵니다.

## `Result`와 `thiserror`
- `Result<T, E>`는 "성공이면 `Ok(T)`, 실패면 `Err(E)`"라는 약속을 표현합니다.
- `thiserror`는 에러 타입을 손쉽게 만들도록 돕는 매크로 모음입니다.
  - `#[derive(thiserror::Error)]`를 붙이면 예쁜 에러 메시지를 자동으로 만들어 줍니다.
- 트랜잭션 수수료가 0이거나 계산 자원이 너무 크면, 에러를 만들어 호출자에게 알려 주세요.

## 비교 순서 정하기
- `BinaryHeap`에 넣는 타입은 `Ord` 트레이트를 구현해야 합니다.
- `Ord`에서는 먼저 `score`를 비교하고, 같으면 `id`를 비교하도록 코드를 작성합니다.
- 이렇게 순서를 명확하게 정의해 두면, 테스트에서도 기대하는 순서를 정확히 체크할 수 있습니다.

## 빠른 테스트 루틴
- 매번 구현이 끝나면 `cargo fmt`, `cargo clippy`, `cargo test`를 순서대로 실행하세요.
- 포맷터와 린터는 실수를 빨리 찾아주고, 테스트는 동작을 지켜 줍니다.
- 이 루틴은 실제 회사에서도 자주 사용하는 기본 루틴입니다.
