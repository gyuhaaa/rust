# YOU_MUST_KNOW Day 7

## 슬롯과 블록 제약은 왜 생길까?
블록체인에서는 한 번에 처리할 수 있는 계산량과 트랜잭션 수가 제한됩니다. 이것을 놀이터 미끄럼틀에 올라갈 수 있는 어린이 수와 한 번 미끄러질 때 걸리는 시간을 제한하는 것과 비슷하게 생각해 보세요. 너무 많은 사람이 몰리면 기다리는 줄이 길어지고, 시스템이 멈춰 버릴 수 있기 때문입니다.

Solana에서는 한 슬롯(slot)마다 사용할 수 있는 **컴퓨트 유닛(Compute Unit)**이 정해져 있습니다. 컴퓨트 유닛은 "이 트랜잭션이 얼마나 많은 계산을 시키나요?"를 숫자로 표현한 값입니다. 또, 한 슬롯에 담을 수 있는 트랜잭션 개수도 제한되어 있어요. 이 두 가지를 모두 지켜야 블록을 정상적으로 만들 수 있습니다.

## 그리디(Greedy) 전략이란?
그리디 전략은 눈앞의 선택을 최선으로 고르면서 전체 문제를 해결하는 방법입니다. 예를 들어 과자를 최대한 많이 담고 싶은데 가방에 무게 제한이 있다면, 무게가 가벼운 과자부터 담아 보는 식입니다. 오늘 과제에서는 제약을 넘기지 않는 선에서 하나씩 트랜잭션을 추가하며 묶음을 만드는 방식이 그리디 전략에 해당합니다.

## `BinaryHeap`은 어떻게 정렬을 도와줄까?
`BinaryHeap`은 항상 가장 큰 값(또는 가장 작은 값)을 바로 꺼낼 수 있도록 설계된 트리 구조입니다. Rust 표준 라이브러리의 `BinaryHeap`은 기본적으로 **가장 큰 값이 먼저 나오는 최대 힙**이에요. `MempoolEntry`가 수수료(`fee_micro_lamports`)가 클수록 "큰 값"이 되도록 `Ord`와 `PartialOrd`를 구현하면, `pop()`을 호출할 때마다 가장 수익성이 높은 트랜잭션부터 나옵니다. 이렇게 꺼낸 항목을 순서대로 벡터에 담으면 자연스럽게 내림차순 정렬이 완성됩니다.

힙을 이용하면 매번 전체 벡터를 정렬할 필요 없이 우선순위가 높은 값만 빠르게 얻을 수 있습니다. 필요한 만큼만 `pop()`해서 쓰거나, 모두 꺼내 `Vec`으로 만들어 순차 처리하는 등 상황에 맞는 선택을 할 수 있다는 장점도 있습니다.

## `bool` 반환이 왜 편할까?
이번 과제의 `try_add` 함수는 제한을 넘기지 않았을 때만 `true`를 돌려줍니다. `true`는 "성공! 담았어요"라는 뜻이고, `false`는 "제한을 넘겨서 담지 않았어요"라는 뜻입니다. 이런 간단한 신호만 있어도 호출한 쪽에서는 추가 행동(예: 로그를 남기거나 다른 항목을 시도하기) 을 결정할 수 있습니다. 복잡한 에러 타입 없이도 흐름을 이해하기 쉬운 장점이 있습니다.

## 반복자(Iterator)를 활용하면 뭐가 좋을까?
반복자는 "차례대로 하나씩 꺼내 보기" 도구입니다. 장난감 상자에서 장난감을 하나씩 꺼내 보는 것처럼, 트랜잭션 벡터에서도 반복자를 통해 항목을 하나씩 살펴볼 수 있습니다. `IntoIterator` 제약을 사용하면 `Vec`, 슬라이스, `BinaryHeap` 등 다양한 자료구조에서도 같은 함수를 재사용할 수 있습니다. 덕분에 코드 중복이 줄고, 테스트 작성도 쉬워집니다.

## 남은 용량 계산은 왜 중요할까?
지금까지 넣은 트랜잭션이 얼마만큼의 자원을 사용했는지 알고 있다면, 앞으로 더 넣을 수 있는지 빠르게 판단할 수 있습니다. 남은 컴퓨트 유닛과 남은 트랜잭션 수를 계산해 놓으면, 추가로 넣을 항목이 들어맞는지 단순 비교로 확인할 수 있습니다. 이번 과제에서 구현하는 `remaining_capacity` 함수는 바로 이러한 판단을 돕는 도우미입니다.

## `saturating_sub`는 어떤 역할을 할까?
보통 숫자를 뺄 때 결과가 음수가 나오면 프로그램이 패닉을 일으킬 수 있습니다. `saturating_sub`는 결과가 음수가 되려고 하면 대신 0을 돌려줍니다. 어린이 용 저금통에서 동전을 빼는데 남은 금액이 음수가 되는 상황을 막아 주는 안전장치라고 생각하면 이해가 쉬워요.

## 오늘의 정리
- 슬롯마다 컴퓨트와 트랜잭션 한도가 있으니, 모든 항목을 검증해야 합니다.
- 그리디 전략은 간단하고 빠르게 "최선의 선택"을 반복하는 방법입니다.
- `bool` 반환은 성공/실패를 가볍게 표현하는 좋은 도구입니다.
- 반복자를 활용하면 다양한 입력을 같은 코드로 처리할 수 있습니다.
- `saturating_sub`는 남은 용량을 계산할 때 언더플로우를 예방해 줍니다.
- `BinaryHeap`은 우선순위가 높은 항목부터 꺼내도록 돕기 때문에 수수료 기반 정렬과 찰떡궁합입니다.
